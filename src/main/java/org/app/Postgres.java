package org.app;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.app.entity.User;

/**
 * Класс, предоставляющий методы для работы с БД Postgres. Методы: insert, exists, getUserPassword, initializeDB.
 *
 * @author Samyrai47
 */
public class Postgres {
  private static String jdbcUrl = "jdbc:postgresql://localhost:5432/postgres";
  private static String username = "postgres";
  private static String password = "738212";

  /**
   * Добавляет запись в БД.
   *
   * @param user пользователь, который будет добавлен в таблицу.
   * @throws SQLException если в процессе добавления в БД что-то пошло не так. Прокидывается в
   *     InMemoryUserRepository.
   */
  public static void insert(User user) throws SQLException {
    Connection connection = DriverManager.getConnection(jdbcUrl, username, password);

    String sqlRequest = "INSERT INTO users(email, passwd, username) " + "VALUES (?, ?, ?)";
    PreparedStatement preparedStatement = connection.prepareStatement(sqlRequest);
    preparedStatement.setString(1, user.getEmail());
    preparedStatement.setString(2, user.getPassword());
    preparedStatement.setString(3, user.getUsername());

    preparedStatement.executeUpdate();

    preparedStatement.close();
    connection.close();
  }

  /**
   * Проверяет, есть ли запись с такой почтой в БД.
   *
   * @param email почта для проверки существования записи
   * @return результат проверки, что записей с нужной почтой 0. Если result != 0, выводит true, т.е.
   *     Запись существует. В противном случае выводит false.
   * @throws SQLException если в процессе проверки в БД что-то пошло не так. Прокидывается в
   *     InMemoryUserRepository.
   */
  public static boolean exists(String email) throws SQLException {
    Connection connection = DriverManager.getConnection(jdbcUrl, username, password);

    String sqlRequest =
        String.format("SELECT COUNT(email) AS total FROM users WHERE email = '%s'", email);
    PreparedStatement preparedStatement = connection.prepareStatement(sqlRequest);
    ResultSet rs = preparedStatement.executeQuery();

    rs.next();
    int result = rs.getInt("total");

    preparedStatement.close();
    connection.close();

    return !(result == 0);
  }

  /**
   * Получает пароль пользователя из БД по его почте. Нет проверки на то, существует ли пользователь
   * - подразумевается, что сначала будет вызван метод Postgres.exists().
   *
   * @param email почта пользователя, по которой будет искаться пароль
   * @return пароль, полученный из БД
   * @throws SQLException если в процессе получения пароля из БД что-то пошло не так. Прокидывается
   *     в InMemoryUserRepository.
   */
  public static String getUserPassword(String email) throws SQLException {
    Connection connection = DriverManager.getConnection(jdbcUrl, username, password);

    String sqlRequest = String.format("SELECT passwd FROM users WHERE email = '%s'", email);
    PreparedStatement preparedStatement = connection.prepareStatement(sqlRequest);
    ResultSet rs = preparedStatement.executeQuery();

    String result = "";
    while (rs.next()) {
      result = rs.getString(1);
    }

    preparedStatement.close();
    connection.close();

    return result;
  }

  /**
   * Создает таблицу users в БД. Без DROP таблицу не создает, даже если ее не существует.
   *
   * @throws SQLException если в процессе создания таблицы в БД что-то пошло не так.
   */
  public static void initializeDB() throws SQLException {
    Connection connection = DriverManager.getConnection(jdbcUrl, username, password);

    String sqlRequest =
        "DROP TABLE IF EXISTS users; "
            + "CREATE TABLE users (user_ID INT GENERATED BY DEFAULT AS IDENTITY, email VARCHAR(30), passwd VARCHAR(20), username VARCHAR(30)); "
            + "ALTER TABLE users ADD CONSTRAINT PK_users PRIMARY KEY (user_ID);";
    PreparedStatement preparedStatement = connection.prepareStatement(sqlRequest);
    preparedStatement.execute();

    preparedStatement.close();
    connection.close();
  }
}
